<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MaterialX: Shader Generation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MaterialX
   &#160;<span id="projectnumber">1.38.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="class_shader.html" title="Class containing all data needed during shader generation.">Shader</a> Generation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md9"></a>
1.1 Scope</h1>
<p>A shader generation framework is implemented as part of MaterialX. This can help applications to transform the agnostic MaterialX data description into executable shader code for a specific renderer. A library module named MaterialXGenShader contains the core shader generation features, and support for specific languages resides in separate libraries, e.g. <a href="/source/MaterialXGenGlsl">MaterialXGenGlsl</a>, <a href="/source/MaterialXGenOsl">MaterialXGenOsl</a>.</p>
<p>Note that this system has no runtime and the output produced is source code, not binary executable code. The source code produced needs to be compiled by a shading language compiler before being executed by the renderer. See Figure 1 for a high level overview of the system.</p>
<p><img src="/documents/Images/shadergen.png" alt="Shader generation with multiple shader generators" class="inline"/></p>
<p><b>Figure 1</b>: <a class="el" href="class_shader.html" title="Class containing all data needed during shader generation.">Shader</a> generation with multiple shader generators.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
1.2 Languages and Shader Generators</h1>
<p>The MaterialX description is free from device specific details and all implementation details needs to be taken care of by shader generators. There is one shader generator for each supported shading language. However for each language there can also be variations needed for different renderers. For example; OpenGL renderers supporting GLSL can use forward rendering or deferred rendering, each with very different requirements for how the shaders are constructed. Another example is different renderers supporting OSL but with different sets of closures or closure parameters. Hence a separate shader generator can be defined for each language/target combination.</p>
<p>Class inheritance and specialization is used to create support for new languages or to customize existing language support for a new target. To add a new shader generator for a target you add a new C++ class derived from the base class <code><a class="el" href="class_shader_generator.html" title="Base class for shader generators All third-party shader generators should derive from this class.">ShaderGenerator</a></code>, or one of the existing derived shader generator classes (<code><a class="el" href="class_glsl_shader_generator.html" title="Base class for GLSL (OpenGL Shading Language) code generation.">GlslShaderGenerator</a></code>, <code><a class="el" href="class_osl_shader_generator.html" title="Base class for OSL (Open Shading Language) shader generators.">OslShaderGenerator</a></code>, etc.), and override the methods you need to customize. You might also need to derive a new <code><a class="el" href="class_syntax.html" title="Base class for syntax objects used by shader generators to emit code with correct syntax for each lan...">Syntax</a></code> class, which is used to handle syntactical differences between different shading languages. Then you need to make sure there are implementations defined for all the nodes you want to support, standard library nodes and nodes from other libraries, by either reusing existing implementations where applicable or adding in new ones. See <b>1.3 <a class="el" href="class_node.html" title="A node element within a NodeGraph or Document.">Node</a> Implementations</b> on how that is done.</p>
<p>Note that a shader generator doesn’t need to be defined at the time when node definitions are added. New shader generators can be added later, and node implementations for new targets can be added for existing nodes.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
1.3 Node Implementations</h1>
<p>There are four different methods to define the implementation of a node:</p><ol type="1">
<li>Using an inline expression.</li>
<li>Using a function written in the target language.</li>
<li>Using a nodegraph that defines the operation performed by the node.</li>
<li>Using a C++ class that emits code dynamically during shader generation.</li>
</ol>
<p>In the following sub-sections each of these methods are explained. For all methods the implementation is tied to a specific <code>nodedef</code> with a well defined interface of typed inputs and outputs.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
1.3.1 Inline Expression</h2>
<p>Provided code generators support a very simple expression language for inlining code. This is useful for simple nodes where the operation can be expressed as a single line of code. Inlining will reduce the number of function calls and produce more compact code. The syntax to use is the same as the target shading language, with the addition of using the node’s input ports as variables wrapped in double curly brackets: <code>{{input}}</code>. The code generator will replace these variables with values assigned or connected to the respective inputs. Figure 2 gives an example.</p>
<p>Connecting the expression to the nodedef is done using an <code>&lt;implementation&gt;</code> element as seen in Figure 2. The file extension is used to differentiate inline expressions from source code functions, using <code>filename.inline</code>.</p>
<div class="fragment"><div class="line">// <span class="keyword">Nodedef</span> <span class="keyword">elements</span> <span class="keyword">for</span> <span class="keyword">node</span> &lt;<span class="keywordtype">add</span>&gt;</div>
<div class="line">&lt;<span class="keywordtype">nodedef</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;ND_add_float&quot;</span> <span class="keyword">node</span>=<span class="stringliteral">&quot;add&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span> <span class="keyword">defaultinput</span>=<span class="stringliteral">&quot;in1&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;in1&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span>/&gt;</div>
<div class="line">  &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;in2&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span>/&gt;</div>
<div class="line">&lt;/<span class="keywordtype">nodedef</span>&gt;</div>
<div class="line">&lt;<span class="keywordtype">nodedef</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;ND_add_color3&quot;</span> <span class="keyword">node</span>=<span class="stringliteral">&quot;add&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;color3&quot;</span> <span class="keyword">defaultinput</span>=<span class="stringliteral">&quot;in1&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;in1&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;color3&quot;</span>/&gt;</div>
<div class="line">  &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;in2&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;color3&quot;</span>/&gt;</div>
<div class="line">&lt;/<span class="keywordtype">nodedef</span>&gt;</div>
<div class="line">&lt;... <span class="keyword">more</span> <span class="keyword">types</span> ...&gt;</div>
<div class="line"> </div>
<div class="line">// <span class="keyword">Implementation</span> <span class="keyword">elements</span> <span class="keyword">for</span> <span class="keyword">node</span> &lt;<span class="keywordtype">add</span>&gt;</div>
<div class="line">&lt;<span class="keywordtype">implementation</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;IM_add_float&quot;</span> <span class="keyword">nodedef</span>=<span class="stringliteral">&quot;ND_add_float&quot;</span> <span class="keyword">file</span>=<span class="stringliteral">&quot;mx_add.inline&quot;</span>/&gt;</div>
<div class="line">&lt;<span class="keywordtype">implementation</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;IM_add_color3&quot;</span> <span class="keyword">nodedef</span>=<span class="stringliteral">&quot;ND_add_color3&quot;</span> <span class="keyword">file</span>=<span class="stringliteral">&quot;mx_add.inline&quot;</span>/&gt;</div>
<div class="line">&lt;... <span class="keyword">more</span> <span class="keyword">types</span> ...&gt;</div>
<div class="line"> </div>
<div class="line">// <span class="keyword">Nodedef</span> <span class="keyword">elements</span> <span class="keyword">for</span> <span class="keyword">node</span> &lt;<span class="keywordtype">mix</span>&gt;</div>
<div class="line">&lt;<span class="keywordtype">nodedef</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;ND_mix_float&quot;</span> <span class="keyword">node</span>=<span class="stringliteral">&quot;mix&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span> <span class="keyword">defaultinput</span>=<span class="stringliteral">&quot;bg&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;fg&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span>/&gt;</div>
<div class="line">  &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;bg&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span>/&gt;</div>
<div class="line">  &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;mix&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span>/&gt;</div>
<div class="line">&lt;/<span class="keywordtype">nodedef</span>&gt;</div>
<div class="line">&lt;<span class="keywordtype">nodedef</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;ND_mix_color3&quot;</span> <span class="keyword">node</span>=<span class="stringliteral">&quot;mix&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;color3&quot;</span> <span class="keyword">defaultinput</span>=<span class="stringliteral">&quot;bg&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;fg&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;color3&quot;</span>/&gt;</div>
<div class="line">  &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;bg&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;color3&quot;</span>/&gt;</div>
<div class="line">  &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;mix&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span>/&gt;</div>
<div class="line">&lt;/<span class="keywordtype">nodedef</span>&gt;</div>
<div class="line">&lt;... <span class="keyword">more</span> <span class="keyword">types</span> ...&gt;</div>
<div class="line"> </div>
<div class="line">// <span class="keyword">Implementation</span> <span class="keyword">elements</span> <span class="keyword">for</span> <span class="keyword">node</span> &lt;<span class="keywordtype">mix</span>&gt;</div>
<div class="line">&lt;<span class="keywordtype">implementation</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;IM_mix_float&quot;</span> <span class="keyword">nodedef</span>=<span class="stringliteral">&quot;ND_mix_float&quot;</span> <span class="keyword">file</span>=<span class="stringliteral">&quot;mx_mix.inline&quot;</span>/&gt;</div>
<div class="line">&lt;<span class="keywordtype">implementation</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;IM_mix_color3&quot;</span> <span class="keyword">nodedef</span>=<span class="stringliteral">&quot;ND_mix_color3&quot;</span> <span class="keyword">file</span>=<span class="stringliteral">&quot;mx_mix.inline&quot;</span>/&gt;</div>
<div class="line">&lt;... <span class="keyword">more</span> <span class="keyword">types</span> ...&gt;</div>
</div><!-- fragment --><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// File &#39;mx_add.inline&#39; contains:</div>
<div class="line">{{in1}} + {{in2}}</div>
<div class="line"> </div>
<div class="line">// File &#39;mx_mix.inline&#39; contains:</div>
<div class="line">mix({{bg}}, {{fg}}, {{mix}})</div>
</div><!-- fragment --><p><b>Figure 2</b>: Inline expressions for implementing nodes <code>&lt;add&gt;</code> and <code>&lt;mix&gt;</code>.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
1.3.2 Shading Language Function</h2>
<p>For nodes that can’t be implemented by inline expressions a function definition can be used instead. The function signature should match the nodedefs interface with inputs and outputs. See Figure 3 for an example. Connecting the source code to the nodedef is done using an <code>&lt;implementation&gt;</code> element, see the <a href="../Specification/MaterialX.v1.36.Spec.pdf">MaterialX specification</a> for more information.</p>
<div class="fragment"><div class="line">// <span class="keyword">Nodedef</span> <span class="keyword">element</span></div>
<div class="line">&lt;<span class="keywordtype">nodedef</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;ND_image_color3&quot;</span> <span class="keyword">node</span>=<span class="stringliteral">&quot;image&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;color3&quot;</span> <span class="keyword">default</span>=<span class="stringliteral">&quot;0.0, 0.0, 0.0&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">parameter</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;file&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;filename&quot;</span>/&gt;</div>
<div class="line">  &lt;<span class="keywordtype">parameter</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;layer&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;string&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;&quot;</span>/&gt;</div>
<div class="line">  &lt;<span class="keywordtype">parameter</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;default&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;color3&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;0.0, 0.0, 0.0&quot;</span>/&gt;</div>
<div class="line">  &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;texcoord&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;vector2&quot;</span> <span class="keyword">defaultgeomprop</span>=<span class="stringliteral">&quot;texcoord&quot;</span>/&gt;</div>
<div class="line">  &lt;<span class="keywordtype">parameter</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;filtertype&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;string&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;linear&quot;</span>/&gt;</div>
<div class="line">  &lt;<span class="keywordtype">parameter</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;uaddressmode&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;string&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;periodic&quot;</span>/&gt;</div>
<div class="line">  &lt;<span class="keywordtype">parameter</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;vaddressmode&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;string&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;periodic&quot;</span>/&gt;</div>
<div class="line">  &lt;<span class="keywordtype">parameter</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;framerange&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;string&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;&quot;</span>/&gt;</div>
<div class="line">  &lt;<span class="keywordtype">parameter</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;frameoffset&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;integer&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;0&quot;</span>/&gt;</div>
<div class="line">  &lt;<span class="keywordtype">parameter</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;frameendaction&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;string&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;black&quot;</span>/&gt;</div>
<div class="line">&lt;/<span class="keywordtype">nodedef</span>&gt;</div>
<div class="line"> </div>
<div class="line">// <span class="keyword">Implementation</span> <span class="keyword">element</span></div>
<div class="line">&lt;<span class="keywordtype">implementation</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;IM_image_color3_osl&quot;</span> <span class="keyword">nodedef</span>=<span class="stringliteral">&quot;ND_image_color3&quot;</span></div>
<div class="line">    <span class="keyword">file</span>=<span class="stringliteral">&quot;mx_image_color3.osl&quot;</span> <span class="keyword">language</span>=<span class="stringliteral">&quot;osl&quot;</span>/&gt;</div>
</div><!-- fragment --><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// File &#39;mx_image_color3.osl&#39; contains:</div>
<div class="line">void mx_image_color3(string file, string layer, color defaultvalue,</div>
<div class="line">                     vector2 texcoord, string filtertype,</div>
<div class="line">                     string uaddressmode, string vaddressmode,</div>
<div class="line">                     string framerange, int frameoffset,</div>
<div class="line">                     string frameendaction, output color out)</div>
<div class="line">{</div>
<div class="line">    // Sample the texture</div>
<div class="line">    out = texture(file, texcoord.x, texcoord.y,</div>
<div class="line">                  &quot;interp&quot;, filtertype,</div>
<div class="line">                  &quot;subimage&quot;, layer,</div>
<div class="line">                  &quot;missingcolor&quot;, defaultvalue,</div>
<div class="line">                  &quot;wrap&quot;, uaddressmode);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Figure 3</b>: Shading language function's implementation for node <code>&lt;image&gt;</code> in OSL.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
1.3.3 Node Graph Implementation</h2>
<p>As an alternative to defining source code, there is also an option to reference a nodegraph as the implementation of a nodedef. The only requirement is that the nodegraph and nodedef have matching inputs and outputs.</p>
<p>This is useful for creating a compound for a set of nodes performing some common operation. It can then be referenced as a node inside other nodegraphs. It is also useful for creating compatibility graphs for unknown nodes. If a node is created by some third party, and its implementation is unknown or proprietary, a compatibility graph can be created using known nodes and be referenced as a stand-in implementation. Linking a nodegraph to a nodedef is done by simply setting a nodedef attribute on the nodegraph definition. See Figure 4 for an example.</p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">nodedef</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;ND_checker_float&quot;</span> <span class="keyword">node</span>=<span class="stringliteral">&quot;checker&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;scale&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;vector2&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;8.0, 8.0&quot;</span>/&gt;</div>
<div class="line">&lt;/<span class="keywordtype">nodedef</span>&gt;</div>
<div class="line">&lt;<span class="keywordtype">nodegraph</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;IM_checker_float&quot;</span> <span class="keyword">nodedef</span>=<span class="stringliteral">&quot;ND_checker_float&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">texcoord</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;texcoord1&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;vector2&quot;</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">parameter</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;index&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;integer&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;0&quot;</span>/&gt;</div>
<div class="line">  &lt;/<span class="keywordtype">texcoord</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">multiply</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;mult1&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;vector2&quot;</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;in1&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;vector2&quot;</span> <span class="keyword">nodename</span>=<span class="stringliteral">&quot;texcoord1&quot;</span>/&gt;</div>
<div class="line">    &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;in2&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;vector2&quot;</span> <span class="keyword">interfacename</span>=<span class="stringliteral">&quot;scale&quot;</span>/&gt;</div>
<div class="line">  &lt;/<span class="keywordtype">multiply</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">swizzle</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;swizz_x&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;in&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;vector2&quot;</span> <span class="keyword">nodename</span>=<span class="stringliteral">&quot;mult1&quot;</span>/&gt;</div>
<div class="line">    &lt;<span class="keywordtype">parameter</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;channels&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;string&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;x&quot;</span>/&gt;</div>
<div class="line">  &lt;/<span class="keywordtype">swizzle</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">swizzle</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;swizz_y&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;in&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;vector2&quot;</span> <span class="keyword">nodename</span>=<span class="stringliteral">&quot;mult1&quot;</span>/&gt;</div>
<div class="line">    &lt;<span class="keywordtype">parameter</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;channels&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;string&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;y&quot;</span>/&gt;</div>
<div class="line">  &lt;/<span class="keywordtype">swizzle</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">floor</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;floor1&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;in&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span> <span class="keyword">nodename</span>=<span class="stringliteral">&quot;swizz_x&quot;</span>/&gt;</div>
<div class="line">  &lt;/<span class="keywordtype">floor</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">floor</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;floor2&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;in&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span> <span class="keyword">nodename</span>=<span class="stringliteral">&quot;swizz_y&quot;</span>/&gt;</div>
<div class="line">  &lt;/<span class="keywordtype">floor</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">add</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;add1&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;in1&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span> <span class="keyword">nodename</span>=<span class="stringliteral">&quot;floor1&quot;</span>/&gt;</div>
<div class="line">    &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;in2&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span> <span class="keyword">nodename</span>=<span class="stringliteral">&quot;floor2&quot;</span>/&gt;</div>
<div class="line">  &lt;/<span class="keywordtype">add</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">modulo</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;mod1&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;in1&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span> <span class="keyword">nodename</span>=<span class="stringliteral">&quot;add1&quot;</span>/&gt;</div>
<div class="line">    &lt;<span class="keywordtype">input</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;in2&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span> <span class="keyword">value</span>=<span class="stringliteral">&quot;2.0&quot;</span>/&gt;</div>
<div class="line">  &lt;/<span class="keywordtype">modulo</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">output</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;out&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;float&quot;</span> <span class="keyword">nodename</span>=<span class="stringliteral">&quot;mod1&quot;</span>/&gt;</div>
<div class="line">&lt;/<span class="keywordtype">nodegraph</span>&gt;</div>
</div><!-- fragment --><p><b>Figure 4</b>: Checker node implementation using a nodegraph.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
1.3.4 Dynamic Code Generation</h2>
<p>In some situations static source code is not enough to implement a node. The code might need to be customized depending on parameters set on the node. Or for a hardware render target vertex streams or uniform inputs might need to be created in order to supply the data needed for the node implementation.</p>
<p>In this case, a C++ class can be added to handle the implementation of the node. The class should be derived from the base class <code><a class="el" href="class_shader_node_impl.html" title="Class handling the shader generation implementation for a node.">ShaderNodeImpl</a></code>. It should specify what language and target it is for by overriding <code>getLanguage()</code> and <code>getTarget()</code>. It can also be specified to support all languages or all targets by setting the identifier to an empty string, as done for the target identifier in the example below. It then needs to be registered for a <code><a class="el" href="class_shader_generator.html" title="Base class for shader generators All third-party shader generators should derive from this class.">ShaderGenerator</a></code> by calling <code><a class="el" href="class_shader_generator.html#a4ed43e2321e4895662d0f48bac040047" title="Register a shader node implementation for a given implementation element name.">ShaderGenerator::registerImplementation()</a></code>. See Figure 5 for an example.</p>
<p>When a <code><a class="el" href="class_shader_node_impl.html" title="Class handling the shader generation implementation for a node.">ShaderNodeImpl</a></code> class is used for a nodedef the corresponding <code>&lt;implementation&gt;</code> element doesn’t need a file attribute, since no static source code is used. The <code>&lt;implementation&gt;</code> element will then act only as a declaration that there exists an implementation for the nodedef for a particular language and target.</p>
<p>Note that by using a <code><a class="el" href="class_shader_node_impl.html" title="Class handling the shader generation implementation for a node.">ShaderNodeImpl</a></code> class for your node's implementation it is no longer data driven, as in the other three methods above. So it's recommneded to use this only when inline expressions or static source code functions are not enough to handle the implementation of a node.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">/// Implementation of ’foo&#39; node for OSL</div>
<div class="line">class FooOsl : public ShaderNodeImpl</div>
<div class="line">{</div>
<div class="line">  public:</div>
<div class="line">    static ShaderNodeImplPtr create() { return std::make_shared&lt;FooOsl&gt;(); }</div>
<div class="line"> </div>
<div class="line">    const string&amp; getLanguage() const override { return LANGUAGE_OSL; }</div>
<div class="line">    const string&amp; getTarget() const override { return EMPTY_STRING; }</div>
<div class="line"> </div>
<div class="line">    void emitFunctionDefinition(const ShaderNode&amp; node, GenContext&amp; context,</div>
<div class="line">                                ShaderStage&amp; stage) const override</div>
<div class="line">    {</div>
<div class="line">        // Emit function definition if needed for the node</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    void emitFunctionCall(const ShaderNode&amp; node, GenContext&amp; context,</div>
<div class="line">                          ShaderStage&amp; stage) const override</div>
<div class="line">    {</div>
<div class="line">        // Emit function call, or inline shader code, for the node</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"> {c++}</div>
<div class="line">OslShaderGenerator::OslShaderGenerator() :</div>
<div class="line">    ShaderGenerator(std::make_shared&lt;OslSyntax&gt;())</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    // Register foo implementation for nodedefs it should be used for</div>
<div class="line">    registerImplementation(&quot;IM_foo_color2_osl&quot;, FooOsl::create);</div>
<div class="line">    registerImplementation(&quot;IM_foo_color3_osl&quot;, FooOsl::create);</div>
<div class="line">    registerImplementation(&quot;IM_foo_color4_osl&quot;, FooOsl::create);</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Figure 5</b>: C++ class for dynamic code generation.</p>
<h1><a class="anchor" id="autotoc_md16"></a>
1.4 Shader Generation Steps</h1>
<p>This section outlines the steps taken in general to produce a shader from the MaterialX description. The <code><a class="el" href="class_shader_generator.html" title="Base class for shader generators All third-party shader generators should derive from this class.">ShaderGenerator</a></code> base class and its supporting classes will handle this for you, but it’s good to know the steps involved if custom changes are needed to support a new target.</p>
<p><a class="el" href="class_shader.html" title="Class containing all data needed during shader generation.">Shader</a> generation supports generating a shader starting from either an <code>output</code> element or a <code>shaderref</code> element in a material. The <code>output</code> can be an output port on a nodegraph or an output element inserted anywhere in a node network. A shader is generated by calling your shader generator class with either of these element types as input. The given element and all dependencies upstream will be translated into a single monolithic shader in the target shading language.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">// Generate a shader starting from the given element, translating</div>
<div class="line">// the element and all dependencies upstream into shader code.</div>
<div class="line">ShaderPtr ShaderGenerator::generate(const string&amp; name,</div>
<div class="line">                                    ElementPtr element,</div>
<div class="line">                                    GenContext&amp; context)</div>
</div><!-- fragment --><p>The shader generation process can be divided into initialization and code generation. The initialization consists of a number of steps:</p><ol type="1">
<li>Create an optimized version of the graph as a tree with the given input element as root, and with only the used dependencies connected upstream. This involves removing unused paths in the graph, converting constant nodes to constant values, and adding in any default nodes for ports that are unconnected but have default connections specified. Removal of unused paths typically involves constant folding and pruning of conditional branches that will never be taken. Since the resulting shader in the end will be compiled by a shading language compiler, and receive a lot of additional optimizations, we don’t need to do too much work in this optimization step. However, a few graph level optimizations can make the resulting shader a lot smaller and save time and memory during shader compilation. It will also produce more readable source code which is good for debugging purposes. This optimization step is also a good place to do other custom optimizations needed by a particular target. For example simplification of the graph, which could involve substituting expensive nodes with approximate nodes, identification of common subgraphs that can be merged, etc.</li>
<li>The nodes are sorted in topological order. Since a node can be referenced by many other nodes in the graph we need an ordering of the nodes so that nodes that have a dependency on other nodes come after all dependent nodes. This step also makes sure there are no cyclic dependencies in the graph.</li>
<li>The stages for the shader are created. For a <a class="el" href="namespace_h_w.html" title="HW specific identifiers.">HW</a> shader this is normally a vertex stage and a pixel stage, but other stages can be added as needed. At the minumum a single pixel stage is required, so even shaders that has no concept of multiple stages, like OSL, needs to have a single pixel stage created.</li>
<li>The shader stages interface of uniforms and varyings are established. This consists of the graph interface ports that are in use, as well as internal ports that have been published to the interface (an example of the latter is for a hardware shader generator where image texture filenames get converted to texture samplers which needs to be published in order to be bound by the target application). Each node in the graph is also called for a chance to create any uniforms or varyings needed by its implementation.</li>
<li>Information about scope is tracked for each node. This information is needed to handle branching by conditional nodes. For example, if a node is used only by a particular branch on a varying conditional we want to calculate this node only inside that scope, when that corresponding branch is taken. A node can be used in global scope, in a single conditional scope or by multiple conditional scopes.</li>
</ol>
<p>The output from the initialization step is a new graph representation constructed using the classes <code><a class="el" href="class_shader_node.html" title="Class representing a node in the shader generation DAG.">ShaderNode</a></code>, <code><a class="el" href="class_shader_input.html" title="An input on a ShaderNode.">ShaderInput</a></code>, <code><a class="el" href="class_shader_output.html" title="An output on a ShaderNode.">ShaderOutput</a></code>, <code><a class="el" href="class_shader_graph.html" title="Class representing a graph (DAG) for shader generation.">ShaderGraph</a></code>, etc. This is a graph representation optimized for shader generation with quick access and traversal of nodes and ports, as well as caching of extra information needed by shader generation.</p>
<p>After initialization the code generation steps are handled by the <code><a class="el" href="class_shader_generator.html" title="Base class for shader generators All third-party shader generators should derive from this class.">ShaderGenerator</a></code> class and derived classes. This part is specific to the particular generator being used, but in general it consists of the following steps:</p><ol type="1">
<li>Typedefs are emitted as specified by the <a class="el" href="class_syntax.html" title="Base class for syntax objects used by shader generators to emit code with correct syntax for each lan...">Syntax</a> class.</li>
<li>Function definitions are emitted for all the atomic nodes that have shading language functions for their implementations. For nodes using dynamic code generation their <code><a class="el" href="class_shader_node_impl.html" title="Class handling the shader generation implementation for a node.">ShaderNodeImpl</a></code> instances are called to generate the functions. For nodes that are implemented by graphs a function definition representing the graph computation is emitted.</li>
<li>The shader signature is emitted with all uniforms set to default values. The shader uniforms can later be accessed on the returned <code><a class="el" href="class_shader.html" title="Class containing all data needed during shader generation.">Shader</a></code> instance in order for applications to be able to bind values to them.</li>
<li>The function calls for all nodes are emitted, in the right dependency order, propagating output results from upstream nodes as inputs to downstream nodes. Inline expressions are emitted instead of functions calls for nodes that use this.</li>
<li>The final shader output is produced and assigned to the shader output variable.</li>
</ol>
<p>Note that if a single monolithic shader for the whole graph is not appropriate for your system the generator can be called on <code>output</code> elements at any point in your graph, and generate code for sub-parts. It is then up to the application to decide where to split the graph, and to assemble the shader code for sub-parts after all have been generated.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
1.5 Shader Stages</h1>
<p>Creation of multiple shader stages is supported. This is needed in order to generate separate code for multiple stages on hardware render targets. A <code>pixel</code> stage must always be created by all targets, even for shading languages like OSL that natively doensn't have a concept of stages. The stage is where the generated shader code is stored as well as all uniforms, inputs and outputs for the shader. This is handled by the <code><a class="el" href="class_shader_stage.html" title="A shader stage, containing the state and resulting source code for the stage.">ShaderStage</a></code> class, and the data can be retrieved from it when generation is completed.</p>
<p>One or more <code><a class="el" href="class_shader_stage.html" title="A shader stage, containing the state and resulting source code for the stage.">ShaderStage</a></code> instances are created and stored on the <code><a class="el" href="class_shader.html" title="Class containing all data needed during shader generation.">Shader</a></code> class. In addition to the <code>pixel</code> stage, hardware generators always specify a <code>vertex</code> stage. If additional stages are needed they can be added as well. When creating shader input variables you specify which stage the variable should be used in, see 1.7 for more information on shader variable creation.</p>
<p><a class="el" href="class_node.html" title="A node element within a NodeGraph or Document.">Node</a> implementations using static source code (function or inline expressions) are always emitted to the <code>pixel</code> stage. Controlling the <code>vertex</code> stage, or other stages, is not supported using static source code. In order to do that you must use dynamic code generation with a custom <code><a class="el" href="class_shader_node_impl.html" title="Class handling the shader generation implementation for a node.">ShaderNodeImpl</a></code> sub-class for your node. You are then able to control how it affects all stages separately. Inside <code>emitFunctionDefinition</code> and <code>emitFunctionCall</code> you can add separate sections for each stage using begin/end shader stage macros. Figure 6 shows how the texcoord node for GLSL is emitting different code into the <code>vertex</code> and <code>pixel</code> stages.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
1.6 Shader Variables</h1>
<p>When generating a shader from a node graph or shaderref the inputs and parameters on those elements will be published as shader uniforms on the resulting shader. A listing of the created uniforms can be read from the produced <code><a class="el" href="class_shader.html" title="Class containing all data needed during shader generation.">Shader</a></code> and <code><a class="el" href="class_shader_stage.html" title="A shader stage, containing the state and resulting source code for the stage.">ShaderStage</a></code> instances. The shader uniforms can then be presented to the user and have their values set by the application.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
1.6.1 Variable Creation</h2>
<p>Adding new uniforms, input and outputs to a shader stage is done by first creating a <code><a class="el" href="class_variable_block.html" title="A block of variables in a shader stage.">VariableBlock</a></code> to store them. There are some predefined identifiers for commonly used variable blocks. For uniforms there are e.g. one named <code>HW::PUBLIC_UNIFORMS</code> and another named <code>HW::PRIVATE_UNIFORMS</code>. Public is used for uniforms to be published to the user, as described above, and private is used for uniforms needed by node implementations but set by the application and not published. For hardware targets there are also specific variable blocks called <code>connector blocks</code> which are used to send data from one stage to another, connecting the stages. A connector block named <code>HW::VERTEX_DATA</code> is used for sending data from the <code>vertex</code> stage to the <code>pixel</code> stage. Variable block creation and handling can be customized as needed by each shader generator target.</p>
<p>All variable blocks can be queried and accessed by the application from the <code><a class="el" href="class_shader_stage.html" title="A shader stage, containing the state and resulting source code for the stage.">ShaderStage</a></code> instances after generation.</p>
<p>Figure 6 shows how creation of shader inputs and connector variables are done for a node implementation that requires this.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">// Implementation of &#39;texcoord&#39; node for GLSL</div>
<div class="line">class TexCoordGlsl : public ShaderNodeImpl</div>
<div class="line">{</div>
<div class="line">  public:</div>
<div class="line">    static ShaderNodeImplPtr create()</div>
<div class="line">    {</div>
<div class="line">        return std::make_shared&lt;TexCoordGlsl&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    void TexCoordNodeGlsl::createVariables(const ShaderNode&amp; node, GenContext&amp;,</div>
<div class="line">                                           Shader&amp; shader) const</div>
<div class="line">    {</div>
<div class="line">        const ShaderOutput* output = node.getOutput();</div>
<div class="line">        const ShaderInput* indexInput = node.getInput(INDEX);</div>
<div class="line">        const string index = indexInput ? indexInput-&gt;getValue()-&gt;getValueString() : &quot;0&quot;;</div>
<div class="line"> </div>
<div class="line">        ShaderStage&amp; vs = shader.getStage(Stage::VERTEX);</div>
<div class="line">        ShaderStage&amp; ps = shader.getStage(Stage::PIXEL);</div>
<div class="line"> </div>
<div class="line">        addStageInput(HW::VERTEX_INPUTS, output-&gt;getType(), &quot;i_texcoord_&quot; + index, vs);</div>
<div class="line">        addStageConnector(HW::VERTEX_DATA, output-&gt;getType(), &quot;texcoord_&quot; + index, vs, ps);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    void TexCoordNodeGlsl::emitFunctionCall(const ShaderNode&amp; node,</div>
<div class="line">                                            GenContext&amp; context,</div>
<div class="line">                                            ShaderStage&amp; stage) const</div>
<div class="line">    {</div>
<div class="line">        const ShaderGenerator&amp; shadergen = context.getShaderGenerator();</div>
<div class="line"> </div>
<div class="line">        const ShaderInput* indexInput = node.getInput(INDEX);</div>
<div class="line">        const string index = indexInput ? indexInput-&gt;getValue()-&gt;getValueString() : &quot;0&quot;;</div>
<div class="line">        const string variable = &quot;texcoord_&quot; + index;</div>
<div class="line"> </div>
<div class="line">        BEGIN_SHADER_STAGE(stage, Stage::VERTEX)</div>
<div class="line">            VariableBlock&amp; vertexData = stage.getOutputBlock(HW::VERTEX_DATA);</div>
<div class="line">            const string prefix = vertexData.getInstance() + &quot;.&quot;;</div>
<div class="line">            ShaderPort* texcoord = vertexData[variable];</div>
<div class="line">            if (!texcoord-&gt;isEmitted())</div>
<div class="line">            {</div>
<div class="line">                shadergen.emitLine(prefix + texcoord-&gt;getVariable() + &quot; = i_&quot; + variable, stage);</div>
<div class="line">                texcoord-&gt;setEmitted();</div>
<div class="line">            }</div>
<div class="line">        END_SHADER_STAGE(shader, Stage::VERTEX)</div>
<div class="line"> </div>
<div class="line">        BEGIN_SHADER_STAGE(stage, Stage::PIXEL)</div>
<div class="line">            VariableBlock&amp; vertexData = stage.getInputBlock(HW::VERTEX_DATA);</div>
<div class="line">            const string prefix = vertexData.getInstance() + &quot;.&quot;;</div>
<div class="line">            ShaderPort* texcoord = vertexData[variable];</div>
<div class="line">                shadergen.emitLineBegin(stage);</div>
<div class="line">            shadergen.emitOutput(node.getOutput(), true, false, context, stage);</div>
<div class="line">            shadergen.emitString(&quot; = &quot; + prefix + texcoord-&gt;getVariable(), stage);</div>
<div class="line">            shadergen.emitLineEnd(stage);</div>
<div class="line">        END_SHADER_STAGE(shader, Stage::PIXEL)</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>Figure 6</b>: <a class="el" href="class_implementation.html" title="An implementation element within a Document.">Implementation</a> of node <code>texcoord</code> in GLSL. Using a <code><a class="el" href="class_shader_node_impl.html" title="Class handling the shader generation implementation for a node.">ShaderNodeImpl</a></code> sub-class in order to control shader variable creation and code generation into separate shader stages.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
1.6.2 Variable Naming Convention</h2>
<p>Creating shader variables and binding values to them needs to be done in agreement with the shader generator side and application side. The application must know what a variable is for in order to bind meaningful data to it. One way of handling this is by using semantics. All shader variables created can be assigned a semantic if that is used by the target application. <a class="el" href="class_shader.html" title="Class containing all data needed during shader generation.">Shader</a> generation does not impose a specific set of semantics to use, so for languages and applications that use this any semantics can be used. For languages that do not use semantics a variable naming convention needs to be used instead.</p>
<p>Built-in shader generators and accompanying node implementations have a naming convention for shader variables. A custom shader generator that derives from and takes advantage of built-in features should preferably use the same convention. Uniform variables are prefixed with <code>u_</code> and vertex inputs with <code>i_</code> . For languages not using semantics, Figure 7 shows the naming used for variables (inputs and uniforms) with predefined binding rules:</p>
<p>App data input variables</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">NAME  </th><th class="markdownTableHeadCenter">TYPE  </th><th class="markdownTableHeadLeft">BINDING   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">i_position  </td><td class="markdownTableBodyCenter">vec3  </td><td class="markdownTableBodyLeft">Vertex position in object space.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">i_normal  </td><td class="markdownTableBodyCenter">vec3  </td><td class="markdownTableBodyLeft">Vertex normal in object space.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">i_tangent  </td><td class="markdownTableBodyCenter">vec3  </td><td class="markdownTableBodyLeft">Vertex tangent in object space.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">i_bitangent  </td><td class="markdownTableBodyCenter">vec3  </td><td class="markdownTableBodyLeft">Vertex bitangent in object space.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">i_texcoord_N  </td><td class="markdownTableBodyCenter">vec2  </td><td class="markdownTableBodyLeft">Vertex texture coord for N:th uv set.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">i_color_N  </td><td class="markdownTableBodyCenter">vec4  </td><td class="markdownTableBodyLeft">Vertex color for N:th color set.   </td></tr>
</table>
<p>Uniform variables</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">NAME  </th><th class="markdownTableHeadCenter">TYPE  </th><th class="markdownTableHeadLeft">BINDING   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">u_worldMatrix  </td><td class="markdownTableBodyCenter">mat4  </td><td class="markdownTableBodyLeft">World transform.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">u_worldInverseMatrix  </td><td class="markdownTableBodyCenter">mat4  </td><td class="markdownTableBodyLeft">World transform, inverted.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">u_worldTransposeMatrix  </td><td class="markdownTableBodyCenter">mat4  </td><td class="markdownTableBodyLeft">World transform, transposed.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">u_worldInverseTransposeMatrix  </td><td class="markdownTableBodyCenter">mat4  </td><td class="markdownTableBodyLeft">World transform, inverted, transposed.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">u_viewMatrix  </td><td class="markdownTableBodyCenter">mat4  </td><td class="markdownTableBodyLeft">View transform.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">u_viewInverseMatrix  </td><td class="markdownTableBodyCenter">mat4  </td><td class="markdownTableBodyLeft">View transform, inverted.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">u_viewTransposeMatrix  </td><td class="markdownTableBodyCenter">mat4  </td><td class="markdownTableBodyLeft">View transform, transposed.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">u_viewInverseTransposeMatrix  </td><td class="markdownTableBodyCenter">mat4  </td><td class="markdownTableBodyLeft">View transform, inverted, transposed.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">u_projectionMatrix  </td><td class="markdownTableBodyCenter">mat4  </td><td class="markdownTableBodyLeft">Projection transform.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">u_projectionInverseMatrix  </td><td class="markdownTableBodyCenter">mat4  </td><td class="markdownTableBodyLeft">Projection transform, inverted.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">u_projectionTransposeMatrix  </td><td class="markdownTableBodyCenter">mat4  </td><td class="markdownTableBodyLeft">Projection transform, transposed.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">u_projectionInverseTransposeMatrix  </td><td class="markdownTableBodyCenter">mat4  </td><td class="markdownTableBodyLeft">Projection transform, inverted, transposed.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">u_worldViewMatrix  </td><td class="markdownTableBodyCenter">mat4  </td><td class="markdownTableBodyLeft">World-view transform.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">u_viewProjectionMatrix  </td><td class="markdownTableBodyCenter">mat4  </td><td class="markdownTableBodyLeft">View-projection transform.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">u_worldViewProjectionMatrix  </td><td class="markdownTableBodyCenter">mat4  </td><td class="markdownTableBodyLeft">World-view-projection transform.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">u_viewPosition  </td><td class="markdownTableBodyCenter">vec3  </td><td class="markdownTableBodyLeft">World-space position of the viewer.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">u_viewDirection  </td><td class="markdownTableBodyCenter">vec3  </td><td class="markdownTableBodyLeft">World-space direction of the viewer.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">u_frame  </td><td class="markdownTableBodyCenter">float  </td><td class="markdownTableBodyLeft">The current frame number as defined by the host application.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">u_time  </td><td class="markdownTableBodyCenter">float  </td><td class="markdownTableBodyLeft">The current time in seconds.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">u_geomprop_&lt;name&gt;  </td><td class="markdownTableBodyCenter">&lt;type&gt;  </td><td class="markdownTableBodyLeft">A named property of given &lt;type&gt; where &lt;name&gt; is the name of the variable on the geometry.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">u_numActiveLightSources  </td><td class="markdownTableBodyCenter">int  </td><td class="markdownTableBodyLeft">The number of currently active light sources. Note that in shader this is clamped against the maximum allowed number of light sources.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">u_lightData[]  </td><td class="markdownTableBodyCenter">struct  </td><td class="markdownTableBodyLeft">Array of struct LightData holding parameters for active light sources. The <code>LightData</code> struct is built dynamically depending on requirements for bound light shaders.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">u_&lt;unitType&gt;UnitTarget[]  </td><td class="markdownTableBodyCenter">integer  </td><td class="markdownTableBodyLeft">An attribute indicating the target unit for a given unit type definition (&lt;unitType&gt;).   </td></tr>
</table>
<p><b>Figure 7</b> : Listing of predefined variables with their binding rules. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
